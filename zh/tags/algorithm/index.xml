<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>algorithm on Mengz's Space ...</title><link>/zh/tags/algorithm/</link><description>Recent content in algorithm on Mengz's Space ...</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Wed, 27 Oct 2010 15:03:32 +0800</lastBuildDate><atom:link href="/zh/tags/algorithm/index.xml" rel="self" type="application/rss+xml"/><item><title>改良鸡尾酒排序算法</title><link>/zh/posts/programming/cocktail-improve/</link><pubDate>Wed, 27 Oct 2010 15:03:32 +0800</pubDate><guid>/zh/posts/programming/cocktail-improve/</guid><description>记得以前学习数据结构和算法时就了解了冒泡排序算法， 前几天的一个面试也被问到了这个问题。于是回来后就又温习了一遍，还了解到了一种冒泡的改良算法，叫做鸡尾酒(cocktail)排序算法，其实现是通过两个循环分别从两端进行冒泡。
通常实现 template&amp;lt; typename T &amp;gt; void cocktail_sort(T array[], int n) { int bottom = 0; int top = n – 1; bool swapped = true; while (swapped) { swapped = false; for ( int i = bottom; i &amp;lt; top; i++ ) { if ( array[i] &amp;gt; array[i+1] ) { swap(array[i], array[i+1]); swapped = true; } } top–; // top is a larger one for ( int i = top; i &amp;gt; bottom; i– ) { if ( array[i] &amp;lt; array[i-1] ) { swap(array[i], array[i-1]); swapped = true; } } bottom++; // bottom is a smaller one } } // end, cocktail_sort 改良实现 我在网上搜索的实现基本上都是上面的实现方法。 我就想为什么不在一个循环中两端一起进行冒泡呢？于是我实现了下面这样的改良的cocktail算法实现，暂且取名为bi_bubble_sort，减少了循环比较的次数：</description></item></channel></rss>