<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>systemd on Mengz's Space ...</title><link>/zh/tags/systemd/</link><description>Recent content in systemd on Mengz's Space ...</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Fri, 03 Dec 2021 15:17:07 +0800</lastBuildDate><atom:link href="/zh/tags/systemd/index.xml" rel="self" type="application/rss+xml"/><item><title>SYSTEMD定时服务</title><link>/zh/posts/linux/systemd-timer/</link><pubDate>Fri, 03 Dec 2021 15:17:07 +0800</pubDate><guid>/zh/posts/linux/systemd-timer/</guid><description>我上一篇文章中介绍的locate文件查找命令，需要依赖updatedb更新索引才能快速查找文件，因此需要定时运行该命令来更新文件索引。我们知道在Linux和类Unix系统上通常使用crontab来创建定时任务。
在Ubuntu上我们使用apt install mlocate之后，会安装一个脚本文件到 /etc/cron.daily/mlocate，也就是通过Cron机制来每天执行updatedb。然而在我的openSUSE上却并未发现有相关的Crontab配置，但我发现索引文件还是在每天的零点进行了更新，那这个定时任务是谁来执行的呢？
我通过查找与mlocate相关的文件，发现了以下几个文件：
❯ locate &amp;#34;mlocate&amp;#34; /etc/systemd/system/timers.target.wants/mlocate.timer /usr/lib/systemd/system/mlocate.service /usr/lib/systemd/system/mlocate.timer 原来在openSUSE系统上，使用的是Systemd的定时单元来实现的。Systemd是一种Linux系统服务管理程序，在我之前的文章在OPENSUSE上使用SYSTEMCTL管理系统服务中介绍过。
那这里我们将重点介绍下Systemd的定时服务（systemd timer unit）。
systemd定时单元 类似与Cron，systemd的定时单元在Linux系统上提供了机制来调度任务，相比于Cron机制，其他具有以下特性（在使用systemd作为初始化和服务管理的系统上）：
调度的任务可以依赖于其他systemd服务 可以使用systemctl命令来管理定时单元，类似与管理systemd服务 除了类似Cron的循环实时定时任务（realtime）之外，还支持一种基于非时间事件触发的任务（monotonic） 定时单元记录日志到systemd的日志系统（journal），因此方便于统一监控和诊断 systemd定时任务的类型 上面的特性中，我们提到其支持两种类型 - realtime 和 monotonic
Realtime - 类似于Cron，这种类型的定时任务由定义的绝对时间来触发，在配置文件中通过 OnCalendar 选项来定义 Monotonic - 这种类型的定时任务将会在指定的事件（例如系统启动，服务激活）一定时间后触发，在配置文件中通过 OnBootSec 和 OnUnitActiveSec ，OnStartupSec 等选项来定义，并且该类型的定时任务触发时间不是固定的，在每一次系统重启之后都会被重置 systemd定时任务的配置 在文章开始，我们在寻找mlocate更新文件索引的定时任务时看到，有文件 /usr/lib/systemd/system/mlocate.timer ，没错，就是通过以 .timer 作为扩展名的systemd单元文件来定义systemd的定时单元的
[Unit] Description=Daily locate database update Documentation=man:updatedb [Timer] OnCalendar=daily AccuracySec=12h Unit=mlocate.service Persistent=true [Install] WantedBy=timers.target 可以看到文件格式与systemd服务的单元文件类似，不过需要 [Timer] 段，在该段定义了如下选项
OnCalendar=daily，意思是每天触发 AccuracySec=12h，意思是由于某些原因需要推测执行的时间 Unit=mlocate.service，这里就是指定了需要执行的任务服务 Persistent=true，指定如果由于关机等原因到时了为能执行任务的情况下，启动会立即触发该任务 那该定时单元指定了 mlocate.service 作为触发执行的任务，也就是 /usr/lib/systemd/system/mlocate.</description></item><item><title>HOSTNAMECTL管理主机名</title><link>/zh/posts/linux/systemd-hostnamectl/</link><pubDate>Sun, 17 May 2015 13:35:00 +0800</pubDate><guid>/zh/posts/linux/systemd-hostnamectl/</guid><description>基于 systemd 的 Linux 系统中提供了一个新的名来 hostnamectl 来管理系统主机名。
当然除了 hostnamectl 之外，还是可以通过原来的 hostname 命令以及修改 /etc/HOSTNAME 来修改主机名。不过使用 hostnamectl 更方便。
hostnamectl的语法 hostnamectl [OPTIONS...] {COMMAND}
有如下 options :
&amp;ndash;static,&amp;ndash;transient,&amp;ndash;pretty 如果用于 status 命令，static 显示当前的静态主机名; transient 显示临时的主机名，一般用于网络临时设置; pretty 显示良好阅读主机名，如&amp;quot;Sam&amp;rsquo;s Computer&amp;quot;。 H, &amp;ndash;host=user@hostname 用来操作远程主机。 命令：
status ： 显示当前系统主机名和相关信息，可以使用 &amp;ndash;static, &amp;ndash;transient, &amp;ndash;pretty 仅显示指定内容。 set-hostname [NAME] ： 设置系统主机名，默认改变 pretty，static，及 transient 。 指定相应选项只改变相应主机名。 set-icon-name [NAME] ： 设置系统 Icon 名，用于一些图形应用来可视化主机。Icon 名需要符合 Icon 名规范。 set-chassis [TYPE] ： 设置 chassis 类型，用于一些图形应用来可视化主机或者改变用户界面。当前设置以下类型：&amp;ldquo;desktop&amp;rdquo;，&amp;ldquo;laptop&amp;rdquo;，&amp;ldquo;server&amp;rdquo;，&amp;ldquo;tablet&amp;rdquo;，&amp;ldquo;handset&amp;rdquo;，还有 &amp;ldquo;vm&amp;rdquo; 和 &amp;ldquo;container&amp;rdquo;。 示例 查看当前主机名及相关信息： $sudo hostnamectl status</description></item><item><title>SYSTEMCTL管理系统服务</title><link>/zh/posts/linux/systemd-systemctl/</link><pubDate>Thu, 29 Jan 2015 18:46:00 +0800</pubDate><guid>/zh/posts/linux/systemd-systemctl/</guid><description>这是我在使用openSuSE过程中学习和使用systemd来管理系统的一些笔记。 首先那就让我们来先看看什么是systemd：
Systemd Systemd是Linux下的一个程序，用来初始化系统。像SysV一样，其将会被Linux内核启动。 在opneSuSE上，systemd将会是系统进程号为1的进程，其负责初始化系统和启动系统服务。
openSuSE从12.3版本开始，用systemd作为默认的系统初始化程序代替了SysV。 想了解systemd和SysV的对于，可以参看这里。
用sytemctl进行系统管理 systemd提供了systemctl命令来进行系统服务管理，其调用格式如下：
systemctl [通用选项] 子命令 [子命令选项]
在系统上管理服务 像SysV一样，通过子命令start|stop|restart等来管理服务：
systemctl start|stop|status|restart|reload|&amp;hellip; &amp;lt;服务名&amp;gt;.service
如查看当前cron服务的状态：
# systemctl status cron.service cron.service - Command Scheduler Loaded: loaded (/usr/lib/systemd/system/cron.service; enabled) Active: active (running) since Mon 2015-01-26 15:50:21 CST; 3 days ago Main PID: 1247 (cron) CGroup: /system.slice/cron.service └─1247 /usr/sbin/cron -n
systemctl支持一次操作多个服务，只要在子命令后添加多个服务名即可。
使用enable|disable来设置开启自动启动或者不启动一个服务：
systemctl enable|disable &amp;lt;服务名&amp;gt;.service
Systemd的启动目标 在SysV的启动系统上，用启动级别（runlevel）来表示系统的启动状态，已经哪些服务伴随这级别一起启动。 如 0 （关闭系统），3 （多用户带网络），5 （多用户带网络，显示图形用户界面）。
而在Systemd上，用目标（target）表示这个概念，如 graphical.target 提供了多用户带网，显示图像用户界面的启动目标，就相当与level 5。 systemd提供了很多内置的目标单元，可以用下面的命令查看：
# systemctl list-unit-files &amp;ndash;type=target</description></item></channel></rss>