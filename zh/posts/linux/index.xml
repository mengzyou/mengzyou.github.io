<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LINUX on Mengz's Space ...</title><link>/zh/posts/linux/</link><description>Recent content in LINUX on Mengz's Space ...</description><generator>Hugo -- gohugo.io</generator><language>en_US</language><lastBuildDate>Sat, 15 Jan 2022 10:04:00 +0800</lastBuildDate><atom:link href="/zh/posts/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>升级OPENSUSE LEAP</title><link>/zh/posts/linux/opensuse-upgrade/</link><pubDate>Sat, 15 Jan 2022 10:04:00 +0800</pubDate><guid>/zh/posts/linux/opensuse-upgrade/</guid><description>openSUSE Leap 15.2自2022年1月4日起已结束生命周（EOL），还在使用该系统的用户未来将不会再收到任何形式的安全与维护更新。
建议所有用户尽快将系统升级到 - openSUSE Leap 15.3，该系统将获得安全补丁和更新直至2022年11月。下一个版本openSUSE Leap 15.4也将预计在2022年6月发布。
喜欢滚动更新版的的朋友，也可以借此机会从Leap版本切换到Tumbleweed版本。
openSUSE Leap的版本升级可以通过联网在线升级，也可以通过下载最新版本的ISO文件进行线下升级，这里面我们将看看如何在线升级。
openSUSE Leap在线升级 使用在线升级的方式有如下优势：
只需要下载需要更新的软件包，将节省不少带宽 在升级期间，虽然不推荐，但是你任然可以使用系统，只有在升级完成后需要重新启动 因为不需要下载ISO镜像文件，所以不需要DVD驱动器或者刻录USB启动盘，需要的仅仅是网络 当然在线升级也有如下缺点：
如果由于某些原因，导致升级过程被中断（例如突然断电，网络连接断开），升级进程无法继续，这有可能会留下一个被破坏的系统 如果有多个系统需要升级，那么下载ISO镜像可能会更省带宽 注意，如果你使用的是更旧的Leap版本，例如 15.1，请先升级到15.2之后，再升级到15.3 。
你可以使用如下命令查看当前版本
&amp;gt; lsb_release -d Description: openSUSE Leap 15.2 虽然正常的升级不会导致用户数据的丢失，但是为了安全，建议在升级之前备份自己重要的个人数据。
升级系统之前的准备 首先检查更新源是否存在并更新当前发行版本的软件包 # zypper repos --uri ... 29 | repo-update | 主更新源 | Yes | ( ) No | No | https://mirrors.tuna.tsinghua.edu.cn/opensuse/update/leap/15.2/oss/ 30 | repo-update-non-oss | 主更新源（非开源软件) | Yes | ( ) No | No | https://mirrors.</description></item><item><title>SYSTEMD定时服务</title><link>/zh/posts/linux/systemd-timer/</link><pubDate>Fri, 03 Dec 2021 15:17:07 +0800</pubDate><guid>/zh/posts/linux/systemd-timer/</guid><description>我上一篇文章中介绍的locate文件查找命令，需要依赖updatedb更新索引才能快速查找文件，因此需要定时运行该命令来更新文件索引。我们知道在Linux和类Unix系统上通常使用crontab来创建定时任务。
在Ubuntu上我们使用apt install mlocate之后，会安装一个脚本文件到 /etc/cron.daily/mlocate，也就是通过Cron机制来每天执行updatedb。然而在我的openSUSE上却并未发现有相关的Crontab配置，但我发现索引文件还是在每天的零点进行了更新，那这个定时任务是谁来执行的呢？
我通过查找与mlocate相关的文件，发现了以下几个文件：
❯ locate &amp;#34;mlocate&amp;#34; /etc/systemd/system/timers.target.wants/mlocate.timer /usr/lib/systemd/system/mlocate.service /usr/lib/systemd/system/mlocate.timer 原来在openSUSE系统上，使用的是Systemd的定时单元来实现的。Systemd是一种Linux系统服务管理程序，在我之前的文章在OPENSUSE上使用SYSTEMCTL管理系统服务中介绍过。
那这里我们将重点介绍下Systemd的定时服务（systemd timer unit）。
systemd定时单元 类似与Cron，systemd的定时单元在Linux系统上提供了机制来调度任务，相比于Cron机制，其他具有以下特性（在使用systemd作为初始化和服务管理的系统上）：
调度的任务可以依赖于其他systemd服务 可以使用systemctl命令来管理定时单元，类似与管理systemd服务 除了类似Cron的循环实时定时任务（realtime）之外，还支持一种基于非时间事件触发的任务（monotonic） 定时单元记录日志到systemd的日志系统（journal），因此方便于统一监控和诊断 systemd定时任务的类型 上面的特性中，我们提到其支持两种类型 - realtime 和 monotonic
Realtime - 类似于Cron，这种类型的定时任务由定义的绝对时间来触发，在配置文件中通过 OnCalendar 选项来定义 Monotonic - 这种类型的定时任务将会在指定的事件（例如系统启动，服务激活）一定时间后触发，在配置文件中通过 OnBootSec 和 OnUnitActiveSec ，OnStartupSec 等选项来定义，并且该类型的定时任务触发时间不是固定的，在每一次系统重启之后都会被重置 systemd定时任务的配置 在文章开始，我们在寻找mlocate更新文件索引的定时任务时看到，有文件 /usr/lib/systemd/system/mlocate.timer ，没错，就是通过以 .timer 作为扩展名的systemd单元文件来定义systemd的定时单元的
[Unit] Description=Daily locate database update Documentation=man:updatedb [Timer] OnCalendar=daily AccuracySec=12h Unit=mlocate.service Persistent=true [Install] WantedBy=timers.target 可以看到文件格式与systemd服务的单元文件类似，不过需要 [Timer] 段，在该段定义了如下选项
OnCalendar=daily，意思是每天触发 AccuracySec=12h，意思是由于某些原因需要推测执行的时间 Unit=mlocate.service，这里就是指定了需要执行的任务服务 Persistent=true，指定如果由于关机等原因到时了为能执行任务的情况下，启动会立即触发该任务 那该定时单元指定了 mlocate.service 作为触发执行的任务，也就是 /usr/lib/systemd/system/mlocate.</description></item><item><title>在LINUX上配置WIREGUARD</title><link>/zh/posts/linux/wireguard-vpn/</link><pubDate>Thu, 03 Dec 2020 11:56:29 +0800</pubDate><guid>/zh/posts/linux/wireguard-vpn/</guid><description>什么是 WireGuard ？ 其官方宣称是快速、现代以及安全的VPN隧道（Fast, Modern, Secure VPN Tunnel）。
WireGuard使用了最先进的加密技术，相比 IPSec 更简单更精简，而且拥有几乎超越 OpenVPN 的性能。其最初是针对Linux内核发布的，但是现在已经跨平台（Windows, MacOS, BSD, Android, iOS等）可部署。
接下来这篇How To系列文章，就来一步步在Ubuntu (Linux)上安装和配置WireGuard VPN，其中一台云主机运行Ubuntu-20.04用作VPN服务器，另一台本地的linux桌面环境作为VPN客户端。
服务器端安装WireGuard 这里我们的服务器使用的是操作系统为Ubuntu 20.04的云主机，对于如何创建并配置一台云主机，可以选择 [DigitalOcean]（https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-20-04）。
这里我们我们已经配置好一台Ubuntu 20.04的云主机，并且可以通过SSH访问。首先对系统进行安全更新
$ sudo apt update $ sudo apt upgrade 接下来直接使用APT安装WireGuard软件包
$ sudo apt install wireguard 会同时安装 wireguard-tools 软件包，我们需要使用其工具进行相关的配置。
配置WireGuard服务端 进入root权限进行操作，为服务端生产私有/公共密钥对
$ sudo -i \# cd /etc/wireguard/ \# umask 077 \# wg genkey | tee privatekey | wg pubkey &amp;gt; publickey 执行完上述命令后，我们会在目录 /etc/wireguard/ 下生产两个密钥文件 privatekey 和 publickey 。</description></item><item><title>LINUX上统计网络接口数据包</title><link>/zh/posts/linux/network-packets/</link><pubDate>Wed, 02 Dec 2020 15:15:03 +0800</pubDate><guid>/zh/posts/linux/network-packets/</guid><description>在Linux系统上，我们可以通过 ip , netstat 或者 [ethtool] 命令显示网络接口丢弃数据包的统计信息。接下来我们看看如何使用每个命令。
使用netstat按接口显示数据包 其实 netstat 命令已经过时，可使用命令 ip 和 ss 来代替。但是 netstat 依然在一些旧的Linux分发版本上可用，因此在 ip/ss 不可用的情况，我们可以使用netstat，其语法如下
netstat -i netstat --interfaces 例如
~$ netstat -i Kernel Interface table Iface MTU Met RX-OK RX-ERR RX-DRP RX-OVR TX-OK TX-ERR TX-DRP TX-OVR Flg docker0 1500 0 188180 0 0 0 151852 0 0 0 BMRU eth0 1500 0 472368 0 0 0 375351 0 0 0 BMRU lo 65536 0 51687 0 0 0 51687 0 0 0 LRU vethc8f46ea 1500 0 136984 0 0 0 79587 0 0 0 BMRU 如果想显示每种协议的概要统计信息，可以执行</description></item><item><title>在UBUNTU上删除旧的内核</title><link>/zh/posts/linux/ubuntu-old-kernel/</link><pubDate>Sun, 08 Dec 2019 23:42:22 +0800</pubDate><guid>/zh/posts/linux/ubuntu-old-kernel/</guid><description>在使用Ubuntu Linux系统时，经常发现在升级Linux内核之后，旧版本的内核包依旧保留在系统中，占据了一定的磁盘空间。系统并不会自动删除掉旧版本的内核，是因为保证在使用新内核无法启动时，还可以选择使用旧版本的内核来启动系统。因此在使用新版本内核启动成功之后，我们需要手动来删除掉一些旧版本的内核包，以释放一定的磁盘空间。那我们如何安全的删除旧版本的内核呢？
删除旧的内核映像 以下是在Ubunut上安全删除旧的Linux内核映像步骤，你不必须以root用户执行命令，或者使用sudo．　步骤一　- 启动到新的内核　首先启动到新安装的内核版本，可以使用如下的命令来验证当前内核版本：
&amp;gt; uname -mrs &amp;gt; uname -a 输出样例如下：
Linux 4.4.0-117-generic x86_64
使用以下命令显示当前系统中已经安装的所有Linux内核映像：
# dpkg --list | egrep -i --color &amp;#39;linux-image|linux-headers&amp;#39; 输出可能如下：
ii linux-headers-4.15.0-45 4.15.0-45.48 all Header files related to Linux kernel version 4.15.0 ii linux-headers-4.15.0-45-generic 4.15.0-45.48 amd64 Linux kernel headers for version 4.15.0 on 64 bit x86 SMP ii linux-headers-generic 4.15.0.45.47 amd64 Generic Linux kernel headers ii linux-image-4.15.0-45-generic 4.15.0-45.48 amd64 Signed kernel image generic ii linux-image-generic 4.</description></item><item><title>LINUX上创建不可删除文件</title><link>/zh/posts/linux/make-undeletable/</link><pubDate>Sat, 24 Aug 2019 15:00:04 +0800</pubDate><guid>/zh/posts/linux/make-undeletable/</guid><description>我们都知道在Linux上默认都会有一个名为root的超级用户，该用户可以修改系统上的任何文件和目录，那我们怎么创建一些不能被删除/修改的文件和目录呢？
那在Linux系统中有一个命令chattr可以用来修改文件和目录的属性，通过该命令就可以设置文件和目录不可删除，甚至包括root也不能操作。
创建不可删除的文件 例如，我们在系统上新建一个名为undeletable-file的文件，通过名了chattr设置其属性为不可修改的：
❯ echo &amp;#34;some contents&amp;#34; ❯ ~/undeletable-file ❯ sudo chattr +i -V ~/undeletable-file chattr 1.43.8 (1-Jan-2018) Flags of /home/mengz/undeletable-file set as ----i-------------- ❯ rm -f ~/undeletable-file rm: cannot remove &amp;#39;undeletable-file&amp;#39;: Operation not permitted ❯ sudo rm -f ~/undeletable-file rm: cannot remove &amp;#39;undeletable-file&amp;#39;: Operation not permitted ❯ echo &amp;#34;change&amp;#34; ❯❯ ~/undeletable-file bash: undeletable-file: Operation not permitted 注意 ： 是用命令chattr修改属性的时候需要root权限，因此这里使用了sudo 。
我们也可以通过命令lsattr来查看当前文件的属性：
❯ lsattr ~/undeletable-file ----i-------------- /home/mengz/undeletable-file 设置目录不可修改 针对目录，同样是用命令chattr，是用-R选项可以递归地修改目录和其文件的属性：</description></item><item><title>BUMBLEBEE禁用NVIDIA显卡</title><link>/zh/posts/linux/bumlebee-nvidia/</link><pubDate>Wed, 25 Nov 2015 01:13:00 +0800</pubDate><guid>/zh/posts/linux/bumlebee-nvidia/</guid><description>如今有很多笔记本电脑都配备了双显卡，一块集成的 Intel 显卡，一块性能更好一些的 NVIDIA 显卡。
可是在平时的使用中可能根本用不上 NVIDIA 的那块显卡，那么为了使这样的笔记本电脑更省电，那么在平时的使用中可以禁用 NVIDIA 的显卡，而只使用集成的显卡。 Bumblebee 就是一个开源项目，在 Linux 上实现了 NVIDIA 的 Optimus 技术，在需要的时候使用 NVIDIA 的显卡。
我的电脑是 Lenovo ThinkPad T440s ，配备了如下的两块显卡：
1. 00:02.0 VGA compatible controller: Intel Corporation Haswell-ULT Integrated Graphics Controller (rev 09) 2. VGA compatible controller: NVIDIA Corporation GK208M [GeForce GT 730M] (rev ff) 而我使用的系统是 openSUSE Leap 42.1，下面就看看如何在该系统上禁用 NVIDIA 的显卡。
安装所需的软件包 首先添加如下安装源：
sudo zypper ar -r http://download.opensuse.org/repositories/X11:/Bumblebee/openSUSE_Leap_42.1/X11:Bumblebee.repo
刷新后，安装如下软件包：
bumblebee nvidia-bumblebee bbswitch bbswitch-kmp-default
如果你是64位系统，还请安装
nvidia-bumblebee-32bit</description></item><item><title>HOSTNAMECTL管理主机名</title><link>/zh/posts/linux/systemd-hostnamectl/</link><pubDate>Sun, 17 May 2015 13:35:00 +0800</pubDate><guid>/zh/posts/linux/systemd-hostnamectl/</guid><description>基于 systemd 的 Linux 系统中提供了一个新的名来 hostnamectl 来管理系统主机名。
当然除了 hostnamectl 之外，还是可以通过原来的 hostname 命令以及修改 /etc/HOSTNAME 来修改主机名。不过使用 hostnamectl 更方便。
hostnamectl的语法 hostnamectl [OPTIONS...] {COMMAND}
有如下 options :
&amp;ndash;static,&amp;ndash;transient,&amp;ndash;pretty 如果用于 status 命令，static 显示当前的静态主机名; transient 显示临时的主机名，一般用于网络临时设置; pretty 显示良好阅读主机名，如&amp;quot;Sam&amp;rsquo;s Computer&amp;quot;。 H, &amp;ndash;host=user@hostname 用来操作远程主机。 命令：
status ： 显示当前系统主机名和相关信息，可以使用 &amp;ndash;static, &amp;ndash;transient, &amp;ndash;pretty 仅显示指定内容。 set-hostname [NAME] ： 设置系统主机名，默认改变 pretty，static，及 transient 。 指定相应选项只改变相应主机名。 set-icon-name [NAME] ： 设置系统 Icon 名，用于一些图形应用来可视化主机。Icon 名需要符合 Icon 名规范。 set-chassis [TYPE] ： 设置 chassis 类型，用于一些图形应用来可视化主机或者改变用户界面。当前设置以下类型：&amp;ldquo;desktop&amp;rdquo;，&amp;ldquo;laptop&amp;rdquo;，&amp;ldquo;server&amp;rdquo;，&amp;ldquo;tablet&amp;rdquo;，&amp;ldquo;handset&amp;rdquo;，还有 &amp;ldquo;vm&amp;rdquo; 和 &amp;ldquo;container&amp;rdquo;。 示例 查看当前主机名及相关信息： $sudo hostnamectl status</description></item><item><title>OPENSUSE上的ZYPPER包管理器</title><link>/zh/posts/linux/opensuse-zypper/</link><pubDate>Mon, 27 Apr 2015 08:07:00 +0800</pubDate><guid>/zh/posts/linux/opensuse-zypper/</guid><description>自己在使用 opensuse，自己非常喜欢 opensuse 的包管理命令行工具 zypper。这里做一个笔记，也希望能看到这个篇文章的朋友能够快速地掌握 zypper 的用法。
CentOS 和 Redhat 使用的是 yum 作为命令行的软件包管理工具。
Debian 和 Ubuntu 使用的是 apt-get。
在 Debian/Ubuntu 上还有另一个软件包管理工具 - aptitude 。
同样，在 SUSE/opensuse Linux 上，zypper 就是其命令行的软件包管理工具。
从高层次的角度，你可以使用 zypper 命令管理两种不同的东西：
管理软件包： 使用 zypper 来安装，删除，更新以及查询本地的或者远端媒体上的软件包。 管理软件源： 也可以使用 zypper 管理软件源信息，你可以在命令行添加，删除，打开或者关闭某个软件源。它还可以设置在安装过程中软件源的优先级。 I. 使用 zypper 管理软件包 1. 安装软件包 使用如下语法安装一个软件包：
zypper install &amp;lt;package name&amp;gt;
如，执行一下命令来安装 火狐浏览器 和它的依赖：
# zypper install MozillaFirefox Loading repository data... Reading installed packages... Resolving package dependencies... The following NEW packages are going to be installed: MozillaFirefox MozillaFirefox-branding-SLED The following packages are not supported by their vendor: MozillaFirefox MozillaFirefox-branding-SLED 2 new packages to install.</description></item><item><title>SYSTEMCTL管理系统服务</title><link>/zh/posts/linux/systemd-systemctl/</link><pubDate>Thu, 29 Jan 2015 18:46:00 +0800</pubDate><guid>/zh/posts/linux/systemd-systemctl/</guid><description>这是我在使用openSuSE过程中学习和使用systemd来管理系统的一些笔记。 首先那就让我们来先看看什么是systemd：
Systemd Systemd是Linux下的一个程序，用来初始化系统。像SysV一样，其将会被Linux内核启动。 在opneSuSE上，systemd将会是系统进程号为1的进程，其负责初始化系统和启动系统服务。
openSuSE从12.3版本开始，用systemd作为默认的系统初始化程序代替了SysV。 想了解systemd和SysV的对于，可以参看这里。
用sytemctl进行系统管理 systemd提供了systemctl命令来进行系统服务管理，其调用格式如下：
systemctl [通用选项] 子命令 [子命令选项]
在系统上管理服务 像SysV一样，通过子命令start|stop|restart等来管理服务：
systemctl start|stop|status|restart|reload|&amp;hellip; &amp;lt;服务名&amp;gt;.service
如查看当前cron服务的状态：
# systemctl status cron.service cron.service - Command Scheduler Loaded: loaded (/usr/lib/systemd/system/cron.service; enabled) Active: active (running) since Mon 2015-01-26 15:50:21 CST; 3 days ago Main PID: 1247 (cron) CGroup: /system.slice/cron.service └─1247 /usr/sbin/cron -n
systemctl支持一次操作多个服务，只要在子命令后添加多个服务名即可。
使用enable|disable来设置开启自动启动或者不启动一个服务：
systemctl enable|disable &amp;lt;服务名&amp;gt;.service
Systemd的启动目标 在SysV的启动系统上，用启动级别（runlevel）来表示系统的启动状态，已经哪些服务伴随这级别一起启动。 如 0 （关闭系统），3 （多用户带网络），5 （多用户带网络，显示图形用户界面）。
而在Systemd上，用目标（target）表示这个概念，如 graphical.target 提供了多用户带网，显示图像用户界面的启动目标，就相当与level 5。 systemd提供了很多内置的目标单元，可以用下面的命令查看：
# systemctl list-unit-files &amp;ndash;type=target</description></item><item><title>OPENSUSE上的定时任务</title><link>/zh/posts/linux/opensuse-cronjob/</link><pubDate>Wed, 02 Feb 2011 15:03:32 +0800</pubDate><guid>/zh/posts/linux/opensuse-cronjob/</guid><description>前段时间，发现每次开机后一段时间机器就会很慢，似乎在跑些什么任务，于是查看系统任务，发现有updatadb（为locate构建数据索引）在运行。这些任务是由 cron 触发的。
于是我用crontab命令来查看当前的cron任务列表，可是得到如下返回：
$sudo crontab -u root -l
root’s password:
no crontab for root
可是我发现在*/etc/cron.daily/目录下有一些脚本， 其中就有一个suse-updatedb*。那些进程就是由这个脚本启动的。 接下来，我查看了一下*/etc/crontab*文件:
-*/15 * * * * root test -x /usr/lib/cron/run-crons &amp;amp;&amp;amp; /usr/lib/cron/run-crons &amp;gt;/dev/null 2&amp;gt;&amp;amp;1
这说明系统会每15分钟调用一次 /usr/lib/cron/run-crons 脚本，接着查看了一下那个脚本，其中发现了一行注释：
# if DAILY_TIME set, run only at a fixed time of day
而DAILY_TIME这个变量应该在*/etc/sysconfig/cron*配置文件里指定，在文件中有这么一段：
## Type: string
## Default: “”
#
# At which time cron.daily should start. Default is 15 minutes after booting
# the system. Example setting would be “14:00″.</description></item><item><title>查看硬件信息</title><link>/zh/posts/linux/what-hardware/</link><pubDate>Fri, 19 Nov 2010 21:33:20 +0800</pubDate><guid>/zh/posts/linux/what-hardware/</guid><description>通常，你也许不需要知道你使用了什么样的硬件 — 你也许拥有的是一台来自比较小一点公司的组装机或者一台二手机。本月，我将介绍你可以用来查看你安装的硬件的工具。 第一步，使用lshw — 列举硬件工具。如果你使用普通用户执行，它会警告你需要使用root执行。因此，以sudo lshw执行。你将可以看到屏幕上显示你系统的信息。第一段将是常规信息，看起来就像下面这样：
jbernard-eeepc
description: Notebook
product: 700
vendor: ASUSTeK Computer INC.
version: 0129
serial: EeePC-1234567890
width: 32 bits
capabilities: smbios-2.5 dmi-2.5 smp-1.4 smp
configuration: boot=normal chassis=notebook
cpus=1 uuid=XXXXXX-XXXXX-XXXXX-XXXXX
这是我在我的ASUS EeePC执行的结果。你可以看到生产商是ASUSTeK, BIOS的版本是0129， 以及这是一台32位的单一CPU机器。更多的信息以下面的分类来说明：
core
firmware - motherboard and BIOS information
cpu - CPU information
cache - cache information
memory - memory information
bank - specific bank memory information
pci - PCI bus information
display - PCI display adapter</description></item></channel></rss>