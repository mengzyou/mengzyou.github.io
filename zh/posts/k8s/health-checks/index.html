<!doctype html><html lang=zh><head><title>K8S健康检查最佳实践</title>
<meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="ie=edge"><link rel=stylesheet href=/application.fb9df7e952c9dccf496d00faec07de633aae460f909bbba4b5e0ad22f5887d73.css integrity="sha256-+5336VLJ3M9JbQD67AfeYzquRg+Qm7ukteCtIvWIfXM="><link rel=icon type=image/png href=/images/site/favicon_hu3d2f89ed4395f8e4a11f46415bebb510_10034_42x0_resize_box_3.png><meta property="og:title" content="K8S健康检查最佳实践"><meta property="og:description" content="我们都知道分布式系统非常难以管理，很大的一个原因是要是整个系统的可用性，是需要所有的部件（服务）都正常工作。如果一个小的部件不可用，系统应该可以检测到，绕过该部件，然后修复它，而且这样的行为应该可以自动进行。
健康检查就是一个简单方法，使系统可以知道应用（服务）的一个实例是否正常工作。如果一个实例能正常工作，那其他服务不应该访问它或者向它发送请求，请求应该发送到健康的实例。而系统应该恢复应用的监控状态。
当我们使用 Kubernetes 来运行和管理我们的应用（服务），默认情况下当一个Pod里的所有容器都启动后，就向该Pod发送相应的流量，并且当容器崩溃的时候重启容器。在一般情况下，这个行为也是可以接受的，不过k8s还提供了对容器的健康检查机制，可以让我们的部署更加健壮。
在演示如何具体配置K8S的健康检查之前，让我们来看看什么健康探测模式（Health Probe Pattern）?
健康探测模式 当我们设计一个关键任务，高可用的应用时，弹性是我们需要考虑的最重要方面之一。当一个应用能快速从失败中恢复，那个这个应用就是具有弹性的。
为了保证基于k8s部署的应用是高可用的，在设计集群时，我们需要遵从特定的设计模式。而健康探测就是其中的一种模式，它定义了应用如何向系统（k8s）报告它自己的健康状态。
这里所谓的健康状态不仅仅是Pod是否启动及运行，还应包括其是否可以正常处理请求并响应，这样k8s就可以更加合理地进行流量路由以及负载均衡。
Kubernetes的健康探测 我们都知道，k8s通过各种控制器对象（Deployment, StatefulSets等）来监控Pod的状态，如果一个控制器检测到Pod由于某些原因崩溃，它就会尝试重新启动Pod，或者把Pod调度到其他节点上进行启动。然而，Pod是可以报告自己的状态的，例如一个使用Nginx作为web服务器的应用，通过Deployment部署到集群里并正常启动，这个时候检测到Pod的的状态是运行着的，但是可能由于某些原因导致访问web服务时确返回500（内部服务错误），对请求者来说该服务是不可用的状态。
默认情况下，k8s的kubelet继续地探测容器的进程，当探测到进程退出，它会重启容器的Pod，有些情况下重启可以让容器恢复正常。但像上面的例子，容器的进行正常运行，而应用却返回500错误，并不能正确地探测到应用的健康状态。
因此，k8s提供了两个类型的探测： 存活探测（Liveness Probe），就绪探测（Readiness Probe）。
存活探测（Liveness Probe） 很多应用在长时间运行，或者遇到某种错误进入死锁状态，除非重启，否则无法恢复。因此k8s提供存活探测（Liveness Probe）来发现并恢复这种状态，当然存活探测检查到错误时，kubelet将对Pod采取重启操作来恢复应用
就绪探测（Readiness Probe） 有时应用会暂时性的不能对外提供网络服务，例如在负载比较大的是偶，或者在应用启动的时候可能需要加载大量数据或做一些初始化的动作，需要一定时间来准备对外提供服务。
这样的情况下，系统探测到应用实例不可用时，不应该杀死应用重启，而是应该分配流量，不往该实例发送请求（通过配置服务负载）。
因此，k8s提供了就绪探测来发现并处理这种情况，发现Pod里的容器为就绪时，会设置应用的service(k8s资源对行)移除该实例的Endpoint（服务端点），使得流量然过该不可用的服务实例，等待探测起就绪后，再将其端点添加回相应的服务。当然如果应用是第一次启动，则会等待就绪探测成功后才会将其添加到服务端点。
Kubernetes探测方法 那系统如何来探测容器的健康状态呢？k8s支持配置三种探测方法： 执行命令，TCP，HTTP 。
三种方法都可以应用到存活和就绪探测。
执行命令 通过在容器内执行命令来判断容器的状态，如果命令返回值为 0，则认为容器是健康的；如果返回值为非 0，则认为容器是不健康的。
这种方式一般在容器运行的应用没有提供HTTP的服务，也没有任何TCP端口启动来提供服务的情况，而可以通过运行一个命令来确定应用是否健康。
下面是配置一个Pod使用命令
apiVersion: v1 kind: Pod metadata: name: app spec: containers: - image: example/app:v1 name: app livenessProbe: exec: command: - cat - /tmp/healthy initialDelaySeconds: 5 上面的示例就使用命令 cat /tmp/healthy 来进行存货探测，如果容器里不存在 /tmp/healthy 文件，则命令返回非0值，k8s则认为容器不健康，这里使用了存活探测，因此会重启该Pod。
TCP 那TCP方式，就是通过尝试向容器监听的端口建立TCP连接来确定其是否健康，如果能成功建立连接，则认为健康，否则不健康。"><meta property="og:type" content="article"><meta property="og:url" content="/zh/posts/k8s/health-checks/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-12-08T17:32:26+08:00"><meta property="article:modified_time" content="2020-12-08T17:32:26+08:00"><meta name=description content="K8S健康检查最佳实践"><script src=https://cdn.counter.dev/script.js data-id=2905461c-37df-49f9-a4ca-0ea1ba64543a data-utcoffset=1></script></head><body class="type-posts kind-page" data-spy=scroll data-target=#TableOfContents data-offset=80><div class="container-fluid bg-dimmed wrapper"><nav class="navbar navbar-expand-xl top-navbar final-navbar shadow"><div class=container><button class="navbar-toggler navbar-light" id=sidebar-toggler type=button>
<span class=navbar-toggler-icon></span>
</button>
<a class=navbar-brand href=/zh/><img src=/images/site/main-logo_hu69a4da50b288ac7c5f97b1e1012a418e_8650_42x0_resize_box_3.png alt=Logo>
Mengz's Space ...</a>
<button class="navbar-toggler navbar-light" id=toc-toggler type=button>
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse lang-selector" id=top-nav-items><ul class="navbar-nav ml-auto"><li class="nav-item dropdown"><a class="nav-link dropdown-toggle" href=# id=themeSelector role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false><img id=navbar-theme-icon-svg src=/icons/moon-svgrepo-com.svg width=20 alt="Dark Theme"></a><div id=themeMenu class="dropdown-menu dropdown-menu-icons-only" aria-labelledby=themeSelector><a class="dropdown-item nav-link" href=# data-scheme=light><img class=menu-icon-center src=/icons/sun-svgrepo-com.svg width=20 alt="Light Theme">
</a><a class="dropdown-item nav-link" href=# data-scheme=dark><img class=menu-icon-center src=/icons/moon-svgrepo-com.svg width=20 alt="Dark Theme">
</a><a class="dropdown-item nav-link" href=# data-scheme=system><img class=menu-icon-center src=/icons/computer-svgrepo-com.svg width=20 alt="System Theme"></a></div></li></ul></div></div><img src=/images/site/main-logo_hu69a4da50b288ac7c5f97b1e1012a418e_8650_42x0_resize_box_3.png class=d-none id=main-logo alt=Logo>
<img src=/images/site/inverted-logo_hu3d2f89ed4395f8e4a11f46415bebb510_10034_42x0_resize_box_3.png class=d-none id=inverted-logo alt="Inverted Logo"></nav><section class=sidebar-section id=sidebar-section><div class=sidebar-holder><div class=sidebar id=sidebar><form class=mx-auto method=get action=/zh/search><input type=text name=keyword placeholder=Search data-search id=search-box></form><div class=sidebar-tree><ul class=tree id=tree><li id=list-heading><a href=/zh/posts/ data-filter=all>Posts</a></li><div class=subtree><li><i class="fas fa-minus-circle"></i><a class=active href=/zh/posts/k8s/>Kubernetes</a><ul class=active><li><a class=active href=/zh/posts/k8s/health-checks/ title=K8S健康检查最佳实践>K8S健康检查最佳实践</a></li><li><a href=/zh/posts/k8s/kubectl-plugins/ title=扩展你的KUBECTL功能>扩展你的KUBECTL功能</a></li><li><a href=/zh/posts/k8s/lightweight-k3s/ title=轻量级Kubernetes集群-K3S>轻量级Kubernetes集群-K3S</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh/posts/linux/>LINUX</a><ul><li><a href=/zh/posts/linux/bumlebee-nvidia/ title=BUMBLEBEE禁用NVIDIA显卡>BUMBLEBEE禁用NVIDIA显卡</a></li><li><a href=/zh/posts/linux/systemd-hostnamectl/ title=HOSTNAMECTL管理主机名>HOSTNAMECTL管理主机名</a></li><li><a href=/zh/posts/linux/make-undeletable/ title=LINUX上创建不可删除文件>LINUX上创建不可删除文件</a></li><li><a href=/zh/posts/linux/network-packets/ title=LINUX上统计网络接口数据包>LINUX上统计网络接口数据包</a></li><li><a href=/zh/posts/linux/opensuse-zypper/ title=OPENSUSE上的ZYPPER包管理器>OPENSUSE上的ZYPPER包管理器</a></li><li><a href=/zh/posts/linux/opensuse-cronjob/ title=OPENSUSE上的定时任务>OPENSUSE上的定时任务</a></li><li><a href=/zh/posts/linux/systemd-systemctl/ title=SYSTEMCTL管理系统服务>SYSTEMCTL管理系统服务</a></li><li><a href=/zh/posts/linux/systemd-timer/ title=SYSTEMD定时服务>SYSTEMD定时服务</a></li><li><a href=/zh/posts/linux/opensuse-upgrade/ title="升级OPENSUSE LEAP">升级OPENSUSE LEAP</a></li><li><a href=/zh/posts/linux/wireguard-vpn/ title=在LINUX上配置WIREGUARD>在LINUX上配置WIREGUARD</a></li><li><a href=/zh/posts/linux/ubuntu-old-kernel/ title=在UBUNTU上删除旧的内核>在UBUNTU上删除旧的内核</a></li><li><a href=/zh/posts/linux/what-hardware/ title=查看硬件信息>查看硬件信息</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh/posts/windows/>Windows</a><ul><li><a href=/zh/posts/windows/windows10-wsl2/ title=Windows10上安装WSL2>Windows10上安装WSL2</a></li><li><a href=/zh/posts/windows/windows10-virtio-image/ title=加载virtio驱动的Windows10安装镜像>加载virtio驱动的Windows10安装镜像</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh/posts/container-tech/>容器技术</a><ul><li><a href=/zh/posts/container-tech/docker-live-restore/ title="DOCKER LIVERESTORE特性">DOCKER LIVERESTORE特性</a></li><li><a href=/zh/posts/container-tech/docker-sbom/ title="DOCKER SBOM镜像物料清单">DOCKER SBOM镜像物料清单</a></li><li><a href=/zh/posts/container-tech/dockerfile-best/ title=DOCKERFILE构建最佳实践>DOCKERFILE构建最佳实践</a></li><li><a href=/zh/posts/container-tech/docker-intro/ title=DOCKER入门>DOCKER入门</a></li><li><a href=/zh/posts/container-tech/mariadb-docker/ title=DOCKER构建MariaDB>DOCKER构建MariaDB</a></li><li><a href=/zh/posts/container-tech/docker-container-app/ title=DOCKER构建容器化应用>DOCKER构建容器化应用</a></li><li><a href=/zh/posts/container-tech/docker-wechat/ title=DOCKER运行微信桌面客户端>DOCKER运行微信桌面客户端</a></li><li><a href=/zh/posts/container-tech/docker-desktop-windows/ title="WINDOWS上的DOCKER DESKTOP">WINDOWS上的DOCKER DESKTOP</a></li><li><a href=/zh/posts/container-tech/docker-compose-v2/ title="开始使用DOCKER COMPOSE V2">开始使用DOCKER COMPOSE V2</a></li><li><a href=/zh/posts/container-tech/smallest-web-container/ title=最小化静态WEB容器实践>最小化静态WEB容器实践</a></li><li><a href=/zh/posts/container-tech/docker-mqtt-broker/ title=本地环境运行MQTT容器>本地环境运行MQTT容器</a></li><li><a href=/zh/posts/container-tech/docker-context-remote/ title=管理远程DOCKER主机>管理远程DOCKER主机</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh/posts/devops/>开发运维</a><ul><li><a href=/zh/posts/devops/github-actions/ title="GITHUB ACTIONS工作流">GITHUB ACTIONS工作流</a></li><li><a href=/zh/posts/devops/gitlab-ci-docker/ title="GITLAB CI自动部署容器应用">GITLAB CI自动部署容器应用</a></li><li><a href=/zh/posts/devops/k3s-terraform-ansible/ title=IaC示例-TERRAFORM&amp;ANSIBLE创建K3S集群>IaC示例-TERRAFORM&amp;ANSIBLE创建K3S集群</a></li><li><a href=/zh/posts/devops/tf-rover/ title=TF执行计划可视化>TF执行计划可视化</a></li><li><a href=/zh/posts/devops/tf-aws-lightsail/ title="TF管理AWS LIGHTSAIL实例">TF管理AWS LIGHTSAIL实例</a></li><li><a href=/zh/posts/devops/single-application-cicd/ title=一体化CI/CD平台>一体化CI/CD平台</a></li><li><a href=/zh/posts/devops/open-gitops/ title="解读OPEN GITOPS 1.0">解读OPEN GITOPS 1.0</a></li><li><a href=/zh/posts/devops/tf-cloud/ title="迁移本地项目到TF CLOUD">迁移本地项目到TF CLOUD</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh/posts/opentool/>开源工具</a><ul><li><a href=/zh/posts/opentool/diun-intro/ title=DIUN-容器镜像更新通知>DIUN-容器镜像更新通知</a></li><li><a href=/zh/posts/opentool/rclone-sync/ title=RCLOUD与云存储同步>RCLOUD与云存储同步</a></li><li><a href=/zh/posts/opentool/find-files/ title=文件系统查找工具>文件系统查找工具</a></li></ul></li><li><i class="fas fa-plus-circle"></i><a href=/zh/posts/programming/>编程</a><ul><li><a href=/zh/posts/programming/cocktail-improve/ title=改良鸡尾酒排序算法>改良鸡尾酒排序算法</a></li><li><a href=/zh/posts/programming/shell-debug/ title=调试Shell脚本错误>调试Shell脚本错误</a></li></ul></li><li><a href=/zh/posts/markdown-sample/ title=Markdown示例>Markdown示例</a></li><li><a href=/zh/posts/shortcodes/ title=短代码示例>短代码示例</a></li></div></ul></div></div></div></section><section class=content-section id=content-section><div class=content><div class="container p-0 read-area"><div class="hero-area col-sm-12" id=hero-area style=background-image:url(/zh/posts/k8s/health-checks/kubernetes-health-checks.webp)></div><div class=page-content><div class="author-profile ml-auto align-self-lg-center"><img class=rounded-circle src=/images/author/mengzyou_huc2c98b30dea57d312a21b09cfacc124e_6244_120x120_fit_q75_h2_box_2.webp alt="Author Image"><h5 class=author-name>You Mengzhe</h5><p>2020年12月8日星期二</p></div><div class=title><h1>K8S健康检查最佳实践</h1></div><div class=taxonomy-terms><ul style=padding-left:0><li class=rounded><a href=/zh/tags/kubernetes/ class="btn, btn-sm">kubernetes</a></li><li class=rounded><a href=/zh/tags/kubectl/ class="btn, btn-sm">kubectl</a></li></ul></div><div class=post-content id=post-content><p>我们都知道分布式系统非常难以管理，很大的一个原因是要是整个系统的可用性，是需要所有的部件（服务）都正常工作。如果一个小的部件不可用，系统应该可以检测到，绕过该部件，然后修复它，而且这样的行为应该可以自动进行。<br>健康检查就是一个简单方法，使系统可以知道应用（服务）的一个实例是否正常工作。如果一个实例能正常工作，那其他服务不应该访问它或者向它发送请求，请求应该发送到健康的实例。而系统应该恢复应用的监控状态。</p><p>当我们使用 <a href=https://kubernetes.io/ target=_blank rel=noopener>Kubernetes</a> 来运行和管理我们的应用（服务），默认情况下当一个Pod里的所有容器都启动后，就向该Pod发送相应的流量，并且当容器崩溃的时候重启容器。在一般情况下，这个行为也是可以接受的，不过k8s还提供了对容器的健康检查机制，可以让我们的部署更加健壮。</p><p>在演示如何具体配置K8S的健康检查之前，让我们来看看什么健康探测模式（Health Probe Pattern）?</p><h2 id=健康探测模式>健康探测模式</h2><p>当我们设计一个关键任务，高可用的应用时，弹性是我们需要考虑的最重要方面之一。当一个应用能快速从失败中恢复，那个这个应用就是具有弹性的。<br>为了保证基于k8s部署的应用是高可用的，在设计集群时，我们需要遵从特定的设计模式。而健康探测就是其中的一种模式，它定义了应用如何向系统（k8s）报告它自己的健康状态。<br>这里所谓的健康状态不仅仅是Pod是否启动及运行，还应包括其是否可以正常处理请求并响应，这样k8s就可以更加合理地进行流量路由以及负载均衡。</p><h2 id=kubernetes的健康探测>Kubernetes的健康探测</h2><p>我们都知道，k8s通过各种控制器对象（Deployment, StatefulSets等）来监控Pod的状态，如果一个控制器检测到Pod由于某些原因崩溃，它就会尝试重新启动Pod，或者把Pod调度到其他节点上进行启动。然而，Pod是可以报告自己的状态的，例如一个使用Nginx作为web服务器的应用，通过Deployment部署到集群里并正常启动，这个时候检测到Pod的的状态是运行着的，但是可能由于某些原因导致访问web服务时确返回500（内部服务错误），对请求者来说该服务是不可用的状态。</p><p>默认情况下，k8s的kubelet继续地探测容器的进程，当探测到进程退出，它会重启容器的Pod，有些情况下重启可以让容器恢复正常。但像上面的例子，容器的进行正常运行，而应用却返回500错误，并不能正确地探测到应用的健康状态。</p><p>因此，k8s提供了两个类型的探测： 存活探测（Liveness Probe），就绪探测（Readiness Probe）。</p><h3 id=存活探测liveness-probe>存活探测（Liveness Probe）</h3><p>很多应用在长时间运行，或者遇到某种错误进入死锁状态，除非重启，否则无法恢复。因此k8s提供存活探测（Liveness Probe）来发现并恢复这种状态，当然存活探测检查到错误时，kubelet将对Pod采取重启操作来恢复应用</p><p><img src=https://images.mengz.dev/posts/kubernetes-probe-livenessae.gif alt=liveness-probe></p><h3 id=就绪探测readiness-probe>就绪探测（Readiness Probe）</h3><p>有时应用会暂时性的不能对外提供网络服务，例如在负载比较大的是偶，或者在应用启动的时候可能需要加载大量数据或做一些初始化的动作，需要一定时间来准备对外提供服务。<br>这样的情况下，系统探测到应用实例不可用时，不应该杀死应用重启，而是应该分配流量，不往该实例发送请求（通过配置服务负载）。<br>因此，k8s提供了就绪探测来发现并处理这种情况，发现Pod里的容器为就绪时，会设置应用的service(k8s资源对行)移除该实例的Endpoint（服务端点），使得流量然过该不可用的服务实例，等待探测起就绪后，再将其端点添加回相应的服务。当然如果应用是第一次启动，则会等待就绪探测成功后才会将其添加到服务端点。</p><p><img src=https://images.mengz.dev/posts/kubernetes-probe-readiness.gif alt=kubernetes-probe-readiness></p><h3 id=kubernetes探测方法>Kubernetes探测方法</h3><p>那系统如何来探测容器的健康状态呢？k8s支持配置三种探测方法： 执行命令，TCP，HTTP 。<br>三种方法都可以应用到存活和就绪探测。</p><h4 id=执行命令>执行命令</h4><p>通过在容器内执行命令来判断容器的状态，如果命令返回值为 0，则认为容器是健康的；如果返回值为非 0，则认为容器是不健康的。<br>这种方式一般在容器运行的应用没有提供HTTP的服务，也没有任何TCP端口启动来提供服务的情况，而可以通过运行一个命令来确定应用是否健康。<br>下面是配置一个Pod使用命令</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span> <span style=color:#f92672>name</span>: <span style=color:#ae81ff>app</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>example/app:v1</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>app</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>livenessProbe</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>exec</span>:
</span></span><span style=display:flex><span>          <span style=color:#f92672>command</span>:
</span></span><span style=display:flex><span>          - <span style=color:#ae81ff>cat</span>
</span></span><span style=display:flex><span>          - <span style=color:#ae81ff>/tmp/healthy</span>
</span></span><span style=display:flex><span>             <span style=color:#f92672>initialDelaySeconds</span>: <span style=color:#ae81ff>5</span>
</span></span></code></pre></div><p>上面的示例就使用命令 <code>cat /tmp/healthy</code> 来进行存货探测，如果容器里不存在 <em>/tmp/healthy</em> 文件，则命令返回非0值，k8s则认为容器不健康，这里使用了存活探测，因此会重启该Pod。</p><h4 id=tcp>TCP</h4><p>那TCP方式，就是通过尝试向容器监听的端口建立TCP连接来确定其是否健康，如果能成功建立连接，则认为健康，否则不健康。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>app</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>example/app:v1</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>name</span>: <span style=color:#ae81ff>app</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>3000</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>livenessProbe</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>tcpSocket</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>port</span>: <span style=color:#ae81ff>3000</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>initialDelaySeconds</span>: <span style=color:#ae81ff>15</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>periodSeconds</span>: <span style=color:#ae81ff>20</span>
</span></span></code></pre></div><p>上面示例了通过配置TCP方式的存活探测，k8s会通过检查Pod端口3000来确认容器是否健康，上面的配置中有两个参数：</p><ul><li>initialDelaySeconds - Pod启动时等待多少时间（15秒）后开始进行检查，该参数用于应用需要一定时间启动的情况，避免一开始就检查失败而导致Pod重启</li><li>periodSeconds - 进行端口检查的周期时间，也就是在Pod运行时，每20秒进行一次检查</li></ul><h4 id=http>HTTP</h4><p>如果应用是一个HTTP服务（或者实现了一个HTTP服务的API来报告健康状态），则可以通过配置HTTP的方式来进行探测</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span> <span style=color:#f92672>name</span>: <span style=color:#ae81ff>app</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span> <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>   - <span style=color:#f92672>image</span>: <span style=color:#ae81ff>exmaple/app:v1</span>
</span></span><span style=display:flex><span>     <span style=color:#f92672>name</span>: <span style=color:#ae81ff>app</span>
</span></span><span style=display:flex><span>     <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>       - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>8080</span>
</span></span><span style=display:flex><span>         <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>     <span style=color:#f92672>livenessProbe</span>:
</span></span><span style=display:flex><span>       <span style=color:#f92672>httpGet</span>:
</span></span><span style=display:flex><span>         <span style=color:#f92672>path</span>: <span style=color:#ae81ff>/</span>
</span></span><span style=display:flex><span>         <span style=color:#f92672>port</span>: <span style=color:#ae81ff>3000</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>initialDelaySeconds</span>: <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>       <span style=color:#f92672>periodSeconds</span>: <span style=color:#ae81ff>20</span>
</span></span></code></pre></div><p>HTTP方式通过向容器的端口和指定路径发送http请求，如果请求的返回值是 200 - 300 之间，则认为是成功的，如果返回值为其他值，例如500，则认为是失败的。</p><p>健康探测还可以配置更多参数来做判定，详细信息可参考 <a href=https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#configure-probes target=_blank rel=noopener>Kubernetes文档</a> 。</p><h2 id=总结>总结</h2><p>在云原生应用之前，主要通过应用日志来监控和分析应用的健康状态，然而当应用不可用时没有什么方法来自动恢复应用。当然日志依然非常有用的，应次也需要日志聚合系统来收集所有应用的日志进行观测和分析应用程序行为。<br>对于分布式系统，以及基于容器的微服务架构云原生应用，我们需要更加快速地将应用从失败中恢复，保证系统的健壮性。因此在进行应用设计的时候，我们应该考虑合适的健康探测模式，在通过Kubernetes进行应用编排的时候，也要尽可能地对容器进行健康状态的探测，是的k8s在发现应用实例不可用的时候，采取保证系统高可用的操作。</p><p>参考：</p><ul><li><a href=https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes target=_blank rel=noopener>配置存活、就绪和启动探测器</a></li><li><a href=https://cloud.google.com/blog/products/gcp/kubernetes-best-practices-setting-up-health-checks-with-readiness-and-liveness-probes target=_blank rel=noopener>Kubernetes best practices: Setting up health checks with readiness and liveness probes</a></li></ul></div><div class="row pl-3 pr-3"><div class="col-md-6 share-buttons"><strong>Share on:</strong>
<a class="btn btn-sm facebook-btn" href="https://www.facebook.com/sharer.php?u=%2fzh%2fposts%2fk8s%2fhealth-checks%2f" target=_blank><i class="fab fa-facebook"></i>
</a><a class="btn btn-sm twitter-btn" href="https://twitter.com/share?url=%2fzh%2fposts%2fk8s%2fhealth-checks%2f&text=K8S%e5%81%a5%e5%ba%b7%e6%a3%80%e6%9f%a5%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5&via=Mengz%27s%20Space%20..." target=_blank><i class="fab fa-twitter"></i>
</a><a class="btn btn-sm linkedin-btn" href="https://www.linkedin.com/shareArticle?url=%2fzh%2fposts%2fk8s%2fhealth-checks%2f&title=K8S%e5%81%a5%e5%ba%b7%e6%a3%80%e6%9f%a5%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5" target=_blank><i class="fab fa-linkedin"></i></a></div></div><hr><div class="row next-prev-navigator"><div class="col-md-12 next-article"><a href=/zh/posts/k8s/kubectl-plugins/ title=扩展你的KUBECTL功能 class="btn btn-outline-info"><div>Next <i class="fas fa-chevron-circle-right"></i></div><div class=next-prev-text>扩展你的KUBECTL功能</div></a></div></div><hr></div></div></div><a id=scroll-to-top class=btn><i class="fas fa-chevron-circle-up"></i></a></section><section class=toc-section id=toc-section><div class=toc-holder><h5 class="text-center pl-3">Table of Contents</h5><hr><div class=toc><nav id=TableOfContents><ul><li><a href=#健康探测模式>健康探测模式</a></li><li><a href=#kubernetes的健康探测>Kubernetes的健康探测</a><ul><li><a href=#存活探测liveness-probe>存活探测（Liveness Probe）</a></li><li><a href=#就绪探测readiness-probe>就绪探测（Readiness Probe）</a></li><li><a href=#kubernetes探测方法>Kubernetes探测方法</a><ul><li><a href=#执行命令>执行命令</a></li><li><a href=#tcp>TCP</a></li><li><a href=#http>HTTP</a></li></ul></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></div></section></div><footer id=footer class="container-fluid text-center align-content-center footer pb-2"><div class="container pt-5"><div class="row text-left"><div class="col-md-4 col-sm-12"><h5>Navigation</h5><ul><li class=nav-item><a class=smooth-scroll href=/zh/#about>关于</a></li><li class=nav-item><a class=smooth-scroll href=/zh/#skills>技能</a></li><li class=nav-item><a class=smooth-scroll href=/zh/#experiences>工作经历</a></li><li class=nav-item><a class=smooth-scroll href=/zh/#education>教育</a></li><li class=nav-item><a class=smooth-scroll href=/zh/#recent-posts>近期文章</a></li><li class=nav-item><a class=smooth-scroll href=/zh/#accomplishments>技能学习</a></li><li class=nav-item><a class=smooth-scroll href=https://live.mengz.dev/>LiveTerm</a></li></ul></div><div class="col-md-4 col-sm-12"><h5>Contact me:</h5><ul><li><a href=mailto:mengz.you@outlook.com target=_blank rel=noopener><span><i class="fas fa-envelope"></i></span> <span>mengz.you@outlook.com</span></a></li><li><a href=https://github.com/mengzyou target=_blank rel=noopener><span><i class="fab fa-github"></i></span> <span>mengzyou</span></a></li><li><a href=https://www.linkedin.com/in/mengzyou target=_blank rel=noopener><span><i class="fab fa-linkedin"></i></span> <span>You Mengzhe</span></a></li></ul></div></div></div><hr><div class=container><div class="row text-left"><div class=col-md-4><a id=theme href=https://github.com/hugo-toha/toha target=_blank rel=noopener><img src=/images/theme-logo_hu8376fd15465fef26ffe66b6bcf0ca686_13669_32x0_resize_box_3.png alt="Toha Theme Logo">
Toha</a></div><div class="col-md-4 text-center">© 2023 Copyright.</div><div class="col-md-4 text-right"><a id=hugo href=https://gohugo.io/ target=_blank rel=noopener>Powered by
<img src=/images/hugo-logo.svg alt="Hugo Logo" height=18></a></div></div></div></footer><script src=/application.3f98eac98ee0e5efd906fd54a896210d7d275efa5f73c9f8712612a554846688.js integrity="sha256-P5jqyY7g5e/ZBv1UqJYhDX0nXvpfc8n4cSYSpVSEZog=" defer></script><script src=https://storage.ko-fi.com/cdn/scripts/overlay-widget.js></script><script>kofiWidgetOverlay.draw("mengz",{type:"floating-chat","floating-chat.donateButton.text":"Buy me a book","floating-chat.donateButton.text-color":"#f9fafc","floating-chat.donateButton.background-color":"#248aaa"})</script></body></html>